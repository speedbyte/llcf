Linux Installations

Check USB Host Controllers
Synchronization Interface in existing CAN Controllers
ISO 11898-1 specifies an optional interface for CAN controllers in support of time triggered communication: 

Each node needs to provide a time base, which is provided either by an internal or by an external clock. Any message received or transmitted invokes a capture of the time base taken at the respective message's reference point, which is the sample point of the SOF bit. After successful message completion, the capture value is provided to the control unit for at least one message and it is readable until the next message is completed. 

It has to be possible to generate at least one programmable event trigger from the above mentioned time base. The trigger should be freely programmable by the control unit. The communication schedule's time slots are divided by trigger events. The automatic retransmission of messages that could not be transmitted successfully must be disabled. 

A hardware implementation also offers additional functions for the synchronization between the TTCAN network and external time references as well as the synchronization between the of several TTCAN networks. 

Schedule Analysis so that all the deadlines are met even at peak load ( maximum message transfer at one time )


AMD Seprom 2800 , Bios from American mEgatrends

DHCP Server, s1nn.net
Host name : Sitar

swap 1.4 GB
ext3 81 GB

installing the debian database system, 
installing the kernel 2.4.


root
germany12

name : Vikas
user name : bajao
germany12

/dev/cdrom

After installing or upgrading, Debian's packaging system can use CD-ROMs, local collections, or networked servers (FTP, HTTP) to automatically install software from (.deb packages). This is done preferably with the `apt' and `aptitude' programs. 
You can install packages from the commandline using apt-get. For example, if you want to install the packages `commprog' and `maxgame', you can give the command 
  apt-get install commprog maxgame 
Note that you don't have to enter the complete path, or the `.deb' extension. `Apt' will figure this out itself. 

Forced local mail delivery to bajao

vesa as x window driver

if you want to revisit this setup process at a later date, just run the base-config program.


C:\Dokumente und Einstellungen\agrawal\Eigene Dateien\Learning\CDAC CD\AllInternetAndWord\linux kernel

cat /proc/bus/usb/usbfs

mount from to

lsmod, mount, dmesg

/proc/scsi/usb-storage-0


Mounting and unmounting

look at the devices  and mount it at the points which you want

for eg. Mount /dev/hda1 /mymount/mydrive

the information will be found in /etc/mtab

umount /mymount/mydrive  to unmount the mounted device

Linux, like all versions of Unix TM presents its hardware devices as special files. So, for example, /dev/null is the null device. A device file does not use any data space in the file system, it is only an access point to the device driver. The EXT2 file system and the Linux VFS both implement device files as special types of inode. There are two types of device file; character and block special files. Within the kernel itself, the device drivers implement file semantices: you can open them, close them and so on. Character devices allow I/O operations in character mode and block devices require that all I/O is via the buffer cache. When an I/O request is made to a device file, it is forwarded to the appropriate device driver within the system. Often this is not a real device driver but a pseudo-device driver for some subsystem such as the SCSI device driver layer. Device files are referenced by a major number, which identifies the device type, and a minor type, which identifies the unit, or instance of that major type. For example, the IDE disks on the first IDE controller in the system have a major number of 3 and the first partition of an IDE disk would have a minor number of 1. So, ls -l of /dev/hda1 gives: 


file filename, gives the information about what is the type of the file


2.2.3  Device drivers
Device drivers make up the major part of the Linux kernel. Like other parts of the operating system, they operate in a highly privileged environment and can cause disaster if they get things wrong. Device drivers control the interaction between the operating system and the hardware device that they are controlling. For example, the filesystem makes use of a general block device interface when writing blocks to an IDE disk. The driver takes care of the details and makes device specific things happen. Device drivers are specific to the controller chip that they are driving which is why, for example, you need the NCR810 SCSI driver if your system has an NCR810 SCSI controller. 
2.2.4  The Filesystems
In Linux, as it is for Unix TM , the separate filesystems that the system may use are not accessed by device identifiers (such as a drive number or a drive name) but instead they are combined into a single hierarchical tree structure that represents the filesystem as a single entity. Linux adds each new filesystem into this single filesystem tree as they are mounted onto a mount directory, for example /mnt/cdrom. One of the most important features of Linux is its support for many different filesystems. This makes it very flexible and well able to coexist with other operating systems. The most popular filesystem for Linux is the EXT2 filesystem and this is the filesystem supported by most of the Linux distributions. 
A filesystem gives the user a sensible view of files and directories held on the hard disks of the system regardless of the filesystem type or the characteristics of the underlying physical device. Linux transparently supports many different filesystems (for example MS-DOS and EXT2) and presents all of the mounted files and filesystems as one integrated virtual filesystem. So, in general, users and processes do not need to know what sort of filesystem that any file is part of, they just use them. 
The block device drivers hide the differences between the physical block device types (for example, IDE and SCSI) and, so far as each filesystem is concerned, the physical devices are just linear collections of blocks of data. The block sizes may vary between devices, for example 512 bytes is common for floppy devices whereas 1024 bytes is common for IDE devices and, again, this is hidden from the users of the system. An EXT2 filesystem looks the same no matter what device holds it. 


Find / -name module.h -print

uname -r

make >& error.out will report all the errors in the file

Specifying path names for include files
When you imbed one source file in another using the #include preprocessor directive, you must supply the name of the file to be included. You can specify a file name either by using a full path name or by using a relative path name.
Use a full path name to imbed files 
The full path name, also called the absolute path name, is the file's complete name starting from the root directory. These path names start with the / (slash) character. The full path name locates the specified file regardless of the directory you are presently in (called your working or current directory).
The following example specifies the full path to file mine.h in John Doe's subdirectory example_prog:
/u/johndoe/example_prog/mine.h
Use a relative path name to imbed files 
The relative path name locates a file relative to the directory that holds the current source file or relative to directories defined using the -Idirectory option.
Directory search sequence for include files using relative path names
C and C++ define two versions of the #include preprocessor directive. IBM XL C/C++ supports both. With the #include directive, the include file name is enclosed between either the < > or " " delimiter characters.
Your choice of delimiter characters will determine the search path used to locate a given include file name. The compiler will search for that include file in all directories in the search path until the include file is found, as follows:

#include type
Directory search order
#include <file_name>
1.The compiler first searches for file_name in each user directory specified by the -Idirectory compiler option, in the order that they appear on the command line. 
2.For C++ compilations, the compiler then searches the directories specified by the -qcpp_stdinc and -qgcc_cpp_stdinc compiler options. 
3.Finally, the compiler then searches the directories specified by the -qc_stdinc and -qgcc_c_stdinc compiler options.
#include "file_name"
1.The compiler first searches for the include file in the directory where your current source file resides. The current source file is the file that contains the directive #include "file_name". 
2.The compiler then searches for the include file according to the search order described above for #include <file_name>.
Notes:
1.file_name specifies the name of the file to be included, and can include a full or partial directory path to that file if you desire. 
If you specify a file name by itself, the compiler searches for the file in the directory search list. 
2.If you specify a file name together with a partial directory path, the compiler appends the partial path to each directory in the search path, and tries to find the file in the completed directory path. 
3.If you specify a full path name, the two versions of the #include directive have the same effect because the location of the file to be included is completely specified.
4.The only difference between the two versions of the #include directive is that the " " (user include) version first begins a search from the directory where your current source file resides. Typically, standard header files are included using the < > (system include) version, and header files that you create are included using the " " (user include) version. 
5.You can change the search order by specifying the -qstdinc and -qidirfirst options along with the -Idirectory option. 
Use the -qnostdinc option to search only the directories specified with the -Idirectory option and the current source file directory, if applicable. 
Use the -qidirfirst option with the #include "file_name" directive to search the directories specified with the -Idirectory option before searching other directories.
Use the -I option to specify the directory search paths.

I have had several sugestions on how to describe volatile, If you have any input please mail me. 
The volatile keyword acts as a data type qualifier. The qualifier alters the default why in which the compiler handles the variable and does not attempt to optimize the storage referenced by it. Martin Leslie 
volatile means the storage is likely to change at anytime and be changed but something outside the control of the user program. This means that if you reference the variable, the program should always check the physical address (ie a mapped input fifo), and not use it in a cashed way.Stephen Hunt 
Here is an example for the usage of the volatile keyword: 
        /* Base address of the data input latch */

        volatile unsigned char *baseAddr;

        /* read parts of output latch */

        lsb    = *handle->baseAddr;
        middle = *handle->baseAddr;
        msb    = *handle->baseAddr;
Between reads the bytes are changed in the latch. 
Without the volatile, the compiler optimises this to a single assignment: 
        lsb = middle = msb = *handle->baseAddr;
Tim Potter 
A volatile variable is for dynamic use. E.G. for data that is to be passed to an I/O port Here is an example. 
        #define TTYPORT 0x17755U

        volatile char *port17 = (char)*TTYPORT;
        *port17 = 'o';
        *port17 = 'N';
Without the volatile modifier, the compiler would think that the statement *port17 = 'o'; is redundant and would remove it from the object code. The volatile statement prevents the compiler optimisation.Alex Arzon. 

Changes : asm.h, smp.h, mpspec.h -> give absolute path


mpsepc.h, smp.h, irq.h, types.h, kernel.h


1. SSH into your server as 'admin' and gain root access by su
2. Copy and paste this line to edit the file for SSH logins
pico -w /etc/ssh/sshd_config
3. Find the line
Protocol 2, 1
4. Uncomment it and change it to look like
Protocol 2
5. Next, find the line
PermitRootLogin yes
6. Uncomment it and make it look like PermitRootLogin no
7. Save the file Ctrl+X then Y then enter
8. Now you can restart SSH
/etc/rc.d/init.d/sshd restart
Now, no one will be able to login to root with out first loggin in as admin and 'su -' to root, and you will be forcing the use of a more secure protocol. Just make sure you remember both passwords


cdrecird –scanbus :for scanning the SCSI related devices
